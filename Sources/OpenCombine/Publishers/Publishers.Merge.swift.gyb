${template_header}
//
//  Publishers.Merge.swift.gyb
//  
//
//  Created by Sergej Jaskiewicz on 04/10/2019.
//
%{
from gyb_opencombine_support import (
    suffix_variadic,
    list_with_suffix_variadic,
    indent
)

import string

instantiations = [(2, 'two', 'second'),
                  (3, 'three', 'third'),
                  (4, 'four', 'fourth'),
                  (5, 'five', 'fifth'),
                  (6, 'six', 'sixth'),
                  (7, 'seven', 'seventh'),
                  (8, 'eight', 'eighth')]

def make_publisher_name(arity):
    return suffix_variadic('Merge', arity, arity - 1)

def make_upstream_types(arity, start=0):
    return [str(c) for c in string.ascii_uppercase[start:arity]]

def make_upstream_types_reversed(arity):
    return [str(c) for c in reversed(string.ascii_uppercase)][:arity]

def make_upstream_generic_constraints(upstream_types, first_is_self=False):

    format_string = '{0}Failure == {1}.Failure, {0}Output == {1}.Output'

    def format(i):
        return format_string.format(upstream_types[i] + '.',
                                    upstream_types[i + 1])

    result = [format(i) for i in range(len(upstream_types) - 1)]

    if first_is_self:
        result.insert(0, format_string.format('', upstream_types[0]))

    return result

def declare_merge_method(arg_count, arity, indent_spaces_count):
    assert(arg_count <= arity - 1)
    is_specialization = arg_count < arity - 1

    declaration_format = """\
public func merge<
    {}
>(with {}) -> Publishers.{}<{}>\
"""

    where_clause_format = '\n    where {}'

    if arg_count == 1:
        upstream_types = ['P']
    elif is_specialization:
        upstream_types = make_upstream_types_reversed(arg_count)
    else:
        upstream_types = make_upstream_types(arg_count + 1, 1)

    method_generic_params = \
        [upstream_type + ': Publisher' for upstream_type in upstream_types]

    cs_method_generic_params = \
        (',\n    ').join(method_generic_params)

    method_args = ['other: P'] \
        if arg_count == 1 else ['{}: {}'.format(upstream_type.lower(), upstream_type) \
                                for upstream_type in upstream_types]

    cs_method_args = ',\n     _ '.join(method_args)

    publisher_name = make_publisher_name(arity)

    self_generic_params = make_upstream_types(arity - arg_count) \
        if is_specialization else ['Self']

    publisher_generic_params = self_generic_params + upstream_types

    cs_publisher_generic_params = ', '.join(publisher_generic_params)

    generic_constraints = make_upstream_generic_constraints(upstream_types, True)

    cs_generic_constraints = \
         ',\n          '.join(generic_constraints)

    declaration = declaration_format.format(cs_method_generic_params,
                                            cs_method_args,
                                            publisher_name,
                                            cs_publisher_generic_params)

    if not is_specialization:
        declaration += where_clause_format.format(cs_generic_constraints)

    return indent(declaration, indent_spaces_count)
}%

extension Publisher {

% for arity, _, _ in instantiations:
%
%     doc_cardinal = 'another publisher' \
%         if arity == 2 else (instantiations[arity - 2][1] + ' other publishers')
%     argument_names = ['other'] \
%         if arity == 2 else [upstream_type.lower() \
%                             for upstream_type in make_upstream_types(arity, 1)]
    /// Combines elements from this publisher with those from ${doc_cardinal},
    /// delivering an interleaved sequence of elements.
    ///
    /// The merged publisher continues to emit elements until all upstream publishers
    /// finish. If an upstream publisher produces an error, the merged publisher fails
    /// with that error.
    ///
    /// - Parameters:
%     for i in range(arity - 1):
%         param_doc = 'Another' if arity == 2 else 'A ' + instantiations[i][2]
    ///   - ${argument_names[i]}: ${param_doc} publisher.
%     end
    /// - Returns: A publisher that emits an event when any upstream publisher emits
    ///   an event.
${declare_merge_method(arity - 1, arity, 4)}
    {
        return .init(self, ${', '.join(argument_names)})
    }
% end
}

extension Publishers {
% for arity, cardinal, _ in instantiations:
%
%     publisher_name = make_publisher_name(arity)
%
%     upstream_types = make_upstream_types(arity)
%
%     upstream_generic_params = \
%         [upstream_type + ': Publisher' for upstream_type in upstream_types]
%
%     cs_upstream_generic_params = \
%         (',\n' + (19 + len(publisher_name)) * ' ').join(upstream_generic_params)
%
%     upstream_generic_constraints = \
%         make_upstream_generic_constraints(upstream_types)
%
%     cs_upstream_generic_constraints = \
%         ',\n              '.join(upstream_generic_constraints)
%
%     init_args = ['_ {}: {}'.format(upstream_type.lower(), upstream_type) \
%                  for upstream_type in upstream_types]
%     cs_init_args = ',\n            '.join(init_args)
%
%     self_fields = [upstream_type.lower() for upstream_type in upstream_types]

    /// A publisher created by applying the merge function to ${cardinal} upstream
    /// publishers.
    public struct ${publisher_name}<${cs_upstream_generic_params}>: Publisher
        where ${cs_upstream_generic_constraints}
    {
        public typealias Output = ${upstream_types[0]}.Output

        public typealias Failure = ${upstream_types[0]}.Failure
%     for upstream_type in upstream_types:

        public let ${upstream_type.lower()}: ${upstream_type}
%     end

        public init(
            ${cs_init_args}
        ) {
%     for self_field in self_fields:
            self.${self_field} = ${self_field}
%     end
        }

        public func receive<Downstream: Subscriber>(subscriber: Downstream)
            where ${upstream_types[0]}.Failure == Downstream.Failure,
                  ${upstream_types[0]}.Output == Downstream.Input
        {
            fatalError("unimplemented")
        }
%     for i in range(len(instantiations) + 1 - arity):
%         argument_names = ['other'] \
%              if i == 0 else [upstream_type.lower() \
%                              for upstream_type in make_upstream_types_reversed(i + 1)]
%

${declare_merge_method(i + 1, arity + i + 1, 8)}
        {
            return .init(${', '.join(self_fields + argument_names)})
        }
%     end
    }
% end
}
